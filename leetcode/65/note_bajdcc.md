## 链接

65.Valid Number(Hard)

## 题目

Validate if a given string is numeric.

Some examples:
`"0"` => `true`
`" 0.1 "` => `true`
`"abc"` => `false`
`"1 a"` => `false`
`"2e10"` => `true`

**Note:** It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.

## 思路

这是数字的匹配，一般涉及编译原理的题目都是hard难度。一般而言，可以采用多重嵌套if判断的方法解决，不过这样没有挑战性，代码也丑，能不能另辟蹊径呢？

**下面的方法非典型，初学者会感到吃力**。要学会这种方法，需要熟练掌握正则表达式的使用，以及一定的编译原理基础。

正则表达式可以表示3型文法，它有一定的语法结构，这样不细说。像电子邮件、网址、电话号码、用户名等都可以用正则表达式进行匹配。而正则表达式常用的功能也就是匹配或者捕获。

这里，数字的正则表达式是`[ ]*[+-]?(\d*\.?\d+|\d+\.?\d*)([e][+-]?\d+)?[ ]*`。

既然是3型文法，那就可以用确定性有限自动机来表示。根据常用方法，要先画出NFA，然后去epsilon边，再进行最小化，那么这里不可能写出这么复杂的代码，因此我偷懒了 :)

参见自己的(解释库)[https://github.com/bajdcc/jMinilang]中的正则匹配部分`priv.bajdcc.util.lexer.test.TestRegex`，直接运行它，然后输入上述正则表达式，那么具体信息就出来了。

详细信息（程序自动生成）：

> #### 正则表达式语法树 ####
> 序列 {
> 	循环{0,-1} {
> 		字符	[\u0020,' ']
> 	}
> 	循环{0,1} {
> 		字符	[\u002b,'+'],[\u002d,'-']
> 	}
> 	分支 {
> 		序列 {
> 			循环{0,-1} {
> 				字符	[\u0030,'0']-[\u0039,'9']
> 			}
> 			循环{0,1} {
> 				字符	[\u002e,'.']
> 			}
> 			循环{1,-1} {
> 				字符	[\u0030,'0']-[\u0039,'9']
> 			}
> 		}
> 		序列 {
> 			循环{1,-1} {
> 				字符	[\u0030,'0']-[\u0039,'9']
> 			}
> 			循环{0,1} {
> 				字符	[\u002e,'.']
> 			}
> 			循环{0,-1} {
> 				字符	[\u0030,'0']-[\u0039,'9']
> 			}
> 		}
> 	}
> 	循环{0,1} {
> 		序列 {
> 			字符	[\u0065,'e']
> 			循环{0,1} {
> 				字符	[\u002b,'+'],[\u002d,'-']
> 			}
> 			循环{1,-1} {
> 				字符	[\u0030,'0']-[\u0039,'9']
> 			}
> 		}
> 	}
> 	循环{0,-1} {
> 		字符	[\u0020,' ']
> 	}
> }

> #### 状态集合 ####
> [\u0020,' ']
> [\u002b,'+']
> [\u002d,'-']
> [\u002e,'.']
> [\u0030,'0']-[\u0039,'9']
> [\u0065,'e']

> #### 最小化 ####
> 状态[0] => 0,
> 	边 => [1]
> 		类型 => 字符区间	[\u0030,'0']-[\u0039,'9']
> 	边 => [0]
> 		类型 => 字符区间	[\u0020,' ']
> 	边 => [2]
> 		类型 => 字符区间	[\u002e,'.']
> 	边 => [3]
> 		类型 => 字符区间	[\u002b,'+']
> 	边 => [3]
> 		类型 => 字符区间	[\u002d,'-']
> 状态[1][结束] => 3,4,6,
> 	边 => [4]
> 		类型 => 字符区间	[\u002e,'.']
> 	边 => [5]
> 		类型 => 字符区间	[\u0065,'e']
> 	边 => [6]
> 		类型 => 字符区间	[\u0020,' ']
> 	边 => [1]
> 		类型 => 字符区间	[\u0030,'0']-[\u0039,'9']
> 状态[2] => 5,
> 	边 => [7]
> 		类型 => 字符区间	[\u0030,'0']-[\u0039,'9']
> 状态[3] => 2,
> 	边 => [2]
> 		类型 => 字符区间	[\u002e,'.']
> 	边 => [1]
> 		类型 => 字符区间	[\u0030,'0']-[\u0039,'9']
> 状态[4][结束] => 5,8,
> 	边 => [5]
> 		类型 => 字符区间	[\u0065,'e']
> 	边 => [6]
> 		类型 => 字符区间	[\u0020,' ']
> 	边 => [4]
> 		类型 => 字符区间	[\u0030,'0']-[\u0039,'9']
> 状态[5] => 10,
> 	边 => [8]
> 		类型 => 字符区间	[\u0030,'0']-[\u0039,'9']
> 	边 => [9]
> 		类型 => 字符区间	[\u002b,'+']
> 	边 => [9]
> 		类型 => 字符区间	[\u002d,'-']
> 状态[6][结束] => 11,
> 	边 => [6]
> 		类型 => 字符区间	[\u0020,' ']
> 状态[7][结束] => 6,
> 	边 => [5]
> 		类型 => 字符区间	[\u0065,'e']
> 	边 => [7]
> 		类型 => 字符区间	[\u0030,'0']-[\u0039,'9']
> 	边 => [6]
> 		类型 => 字符区间	[\u0020,' ']
> 状态[8][结束] => 14,
> 	边 => [6]
> 		类型 => 字符区间	[\u0020,' ']
> 	边 => [8]
> 		类型 => 字符区间	[\u0030,'0']-[\u0039,'9']
> 状态[9] => 13,
> 	边 => [8]
> 		类型 => 字符区间	[\u0030,'0']-[\u0039,'9']

> #### 状态转移矩阵 ####
> 	0	3	3	2	1	-1
> 	6	-1	-1	4	1	5
> 	-1	-1	-1	-1	7	-1
> 	-1	-1	-1	2	1	-1
> 	6	-1	-1	-1	4	5
> 	-1	9	9	-1	8	-1
> 	6	-1	-1	-1	-1	-1
> 	6	-1	-1	-1	7	5
> 	6	-1	-1	-1	8	-1
> 	-1	-1	-1	-1	8	-1

## 代码

利用DFA状态转移表进行匹配。


```c++

//代码放在这个块里面，可以高亮关键字
class Solution {
    inline int getCharMap(const char& c) {
        switch (c) {
            case ' ':
                return 0;
            case '+':
                return 1;
            case '-':
                return 2;
            case '.':
                return 3;
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                return 4;
            case 'e':
                return 5;
        }
        return -1;
    }

public:
    bool isNumber(string s) {
        using t = int(*)[6];
        int mm[] = {
                0	,3	,3	,2	,1	,-1,
                6	,-1	,-1	,4	,1	,5,
                -1	,-1	,-1	,-1	,7	,-1,
                -1	,-1	,-1	,2	,1	,-1,
                6	,-1	,-1	,-1	,4	,5,
                -1	,9	,9	,-1	,8	,-1,
                6	,-1	,-1	,-1	,-1	,-1,
                6	,-1	,-1	,-1	,7	,5,
                6	,-1	,-1	,-1	,8	,-1,
                -1	,-1	,-1	,-1	,8	,-1,
        };
        auto m = (t)mm;
        bool final[] = {0, 1, 0, 0, 1, 0, 1, 1, 1, 0};
        int status = 0;
        auto c = s.c_str();
        for (;;) {
            auto local = *c++;
            int charClass = getCharMap(local);
            int refer = -1;
            if (charClass != -1) {
                refer = m[status][charClass];
            }
            if (refer == -1) {
                return local == 0 && final[status];
            } else {
                status = refer;
            }
        }
    }
};

```



## 更多

![](https://github.com/githubwoniu/learnprogram/blob/master/image/erweima.png)

PS: 请保留二维码链接，以便更多人参与进来。谢谢。